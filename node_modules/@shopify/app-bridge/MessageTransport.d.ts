import { AnyAction } from './actions/types';
import { TransportDispatch } from './client';
declare global {
    interface Window {
        SmartWebView: {
            handleMessage: (message: String, data?: String) => void;
        };
    }
}
export declare enum Context {
    Modal = "Modal",
    Main = "Main"
}
/**
 * @deprecated Not to be used, use regular `MessageEvent` instead.
 * @internal
 */
export declare type HandlerData = {
    data: AnyAction;
};
/**
 * @internal
 */
export declare type Handler = (event: MessageEvent) => void;
/**
 * @internal
 */
export interface MessageTransport {
    dispatch(message: TransportDispatch): void;
    hostFrame: Window;
    localOrigin: string;
    subscribe(handler: Handler): () => void;
}
export interface ContextualMessageTransport extends MessageTransport {
    context: Context;
    frameWindow: Window | null;
    dispatch(message: any): void;
}
/**
 * Create a MessageTransport from an IFrame.
 * @remarks
 * Used on the host-side to create a postMessage MessageTransport.
 * @beta
 */
export declare function fromFrame(frame: HTMLIFrameElement, localOrigin: string, context: Context): ContextualMessageTransport;
/**
 * Create a MessageTransport from a parent window.
 * @remarks
 * Used on the client-side to create a postMessage MessageTransport.
 * @internalremarks
 * In frameless mode, message should be dispatched via SmartWebView.handleMessage instead of postMessage.
 * @beta
 */
export declare function fromWindow(contentWindow: Window, localOrigin: string): MessageTransport;
